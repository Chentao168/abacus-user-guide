{"./":{"url":"./","title":"ABACUS使用教程","keywords":"","body":"ABACUS使用教程 一、介绍 ABACUS是国产开源密度泛函理论软件。本教程系列旨在帮助新手用户入门了解ABACUS的使用。秉着开源软件的理念，本文档是由开源社区的老师同学们贡献所成。如果你也想贡献一份文档，我们十分欢迎，请参考如何贡献ABACUS使用教程 二、ABACUS基本操作教程 ABACUS的编译介绍 官方编译教程 知乎上用户提供的ABACUS 3.0安装教程 编译无MPI的ABACUS 曙光DCU平台编译教程：ABACUS DCU版本编译指南 ABACUS建模介绍 准备晶胞和原子位置等信息的文件STRU：如何转换STRU的格式 数值原子轨道基组生成教程：如何产生ABACUS中的数值原子轨道文件 准备赝势（缺） Kohn-Sham密度泛函理论 电子自洽迭代 平面波PW（缺） 数值原子轨道LCAO（缺） 带自旋的体系计算（缺，郑大也写） +U计算：ABACUS DFT+U使用教程 结构优化（缺） 分子动力学：ABACUS 分子动力学使用教程 DeePKS方法（缺） 隐式溶剂计算等相关功能（缺，找许审镇老师） 随机波函数密度泛函理论：ABACUS 随机波函数DFT方法使用教程 分析结果 能带计算 如何正确画能带，NSCF读电荷密度 用ABACUS-ASE自动产生能带路径 PDOS计算 ABACUS里怎样做DOS和PDOS计算 和其他软件对接 ABACUS+Phonopy教程：ABACUS+Phonopy计算声子谱 ABACUS+CINEB教程（缺，找许审镇老师） ABACUS-ASE做NEB计算 （简单算例） ABACUS+ShengBTE教程：ABACUS+ShengBTE 计算晶格热导率 ABACUS+DPGEN教程：ABACUS+DPGEN 使用教程 三、使用经验 有VASP使用背景的用户上手ABACUS教程：ABACUS新人使用的一些注意事项 ABACUS进行LCAO计算前轨道基组测试教程：LCAO具体计算前的基本参数测试教程文档 对比测试ABACUS中解析计算的晶格应力与能量差分方法计算的晶格应力的教程：差分测试规范 四、ABACUS+DFLOW使用教程 案例1：轨道基组对所有元素的计算准确性的delta测试：ABACUS+dflow做delta测试 案例2：ABACUS+dflow做应力差分测试 案例3：ABACUS+dflow跑Examples里的算例 案例4：ABACUS+dflow+Phonopy声子谱计算 案例5：ABACUS+dflow做弹性常数计算 "},"abacus-md.html":{"url":"abacus-md.html","title":"ABACUS 分子动力学使用教程","keywords":"","body":"ABACUS 分子动力学使用教程 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn，最后更新时间：2023/05/28 1. 分子动力学方法简介 分子动力学（Molecular Dynamics，简称 MD）：一种模拟原子体系随时间运动的方法，被广泛的用来研究与原子运动路径相关的一些基本过程，如相变、扩散、化学反应等等。本教程旨在介绍 ABACUS 中的分子动力学功能，分子动力学模拟重要的一件事情是如何选取精度和效率的平衡，其中精度高低主要取决于势函数的准确程度，而效率主要受限于求出每个原子的能量和受力的计算量。 经典分子动力学（Classical MD，简称 CMD）：通过构建描述原子间相互作用的势函数，获得每个原子的受力（受力等于能量对原子位置的导数），再通过积分运动方程来获得每个原子的下一时刻位置，从而获得随时间演化的粒子位置和速度。当系统处在一定的密度、温度和压强等物理条件限制下，可以结合统计物理的方法计算物质的性质。具体来说，采取某个系综后，对粒子位置和速度采样，之后统计出体系的热力学宏观性质。 从头算分子动力学（ab initio molecular dynamics，简称 AIMD）：也称为第一性原理的分子动力学方法（first-principles molecular dynamics，简称 FPMD），该方法采用的是第一性原理方法（例如密度泛函理论）来计算体系的势能面，因此计算量相比于经典分子动力学方法要昂贵很多。 ABACUS 的分子动力学功能：支持第一性原理分子动力学 FPMD 方法，也支持经典的 Lennard-Jones（LJ 对势）的分子动力学模拟。此外，ABACUS 还支持深度势能分子动力学（Deep Potential Molecular Dynamics，简称 DPMD）方法，此时需要编译 DeePMD-kit 软件包并在编译原子算筹软件时进行动态库的链接。 2. 文档和算例下载地址 ABACUS 里关于分子动力学方法的线上文档地址为：http://abacus.deepmodeling.com/en/latest/advanced/md.html ABACUS 里关于分子动力学参数的线上文档地址为： http://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#molecular-dynamics ABACUS 的 MD 算例下载地址为（国内 gitee）： https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/md 可以采用的下载命令是： git clone https://gitee.com/mcresearch/abacus-user-guide.git 之后进入 /abacus-user-guide/examples/md 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide/tree/master/examples/md 注：算例仓库里面包含 1_AIMD，2_LJMD（采用 Lennard-Jones 经典势做 MD）和 3_DPMD（采用深度势能方法做 MD）三个目录。 注：以上算例要在ABACUS v3.2.1版本及以上可以运行成功。 2.1 第一性原理分子动力学（AIMD） 进入 1_AIMD 目录，该目录提供了 8 个输入文件，使用的时候将 INPUT_* 复制为 INPUT 即可（INPUT_* 代表从 INPUT_0 到 INPUT_7 共 8 个不同的 INPUT 文件，对应 8 种不同的 MD 算法）。该算例采用 8 原子的金刚石结构 Si，晶格结构放在 STRU 文件里，布里渊区的 k 点采样放在 KPT 文件里。 8 个 INPUT 文件对应的 MD 方法如下： INPUT_0：采用 NVE 微正则系综 INPUT_1：采用 NVT 正则系综 INPUT_2：采用 Langevin 热库 INPUT_3：采用 Anderson 热库，NVT 系综 INPUT_4：采用 MSST 方法 INPUT_5：采用 Berendsen 热库，NVT 系综 INPUT_6：采用 rescaling 方法，NVT 系综 INPUT_7：采用 rescale_v 方法，NVT 系综 以 INPUT_0 为例： INPUT_PARAMETERS #Parameters (1.General) suffix Si_nve calculation md nbands 20 symmetry 0 pseudo_dir ../../../tests/PP_ORB orbital_dir ../../../tests/PP_ORB #Parameters (2.Iteration) ecutwfc 30 scf_thr 1e-5 scf_nmax 100 #Parameters (3.Basis) basis_type lcao ks_solver genelpa gamma_only 1 #Parameters (4.Smearing) smearing_method gaussian smearing_sigma 0.001 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.3 chg_extrap second-order #Parameters (6.MD) md_type nve md_nstep 10 md_dt 1 md_tfirst 300 这些参数在 ABACUS 线上文档中均有说明，在这里再进行简单概述： calculation：设置 ABACUS 计算类型，做分子动力学模拟请设置为 md。 esolver_type：给定原子位置进行系统能量的计算，默认 Kohn-Sham 密度泛函理论（ksdft），还可以设置 LJ 势（lj）或者深度势能（dp）。理论上来说，所有的 esolver_type 都可以用于 MD 计算。 chg_extrap：电荷外插法，在 relax 和 md 计算中可用于优化电荷密度初始化，加速电子迭代收敛，MD 中可以设置为 second-order。 md_type：MD 算法种类，默认是正则系统 nvt，这里的例子选择的是 nve，即 NVE 微正则系综。 md_nstep：MD 模拟的总步数。 md_dt：MD 计算每一步的时间步长（单位是 fs），与 md_nstep 共同决定 MD 总时长。 md_tfirst：MD 系统的初始温度（单位是 K）。 2.2 Lennard-Jones 势函数 进入 2_LJMD 目录，ABACUS 软件包中提供了一个采用 Lennard-Jones（LJ）经典势函数进行 MD 模拟的算例，该算例采用 LJ 对势作为能量求解器来做经典分子动力学，初始结构是边长 20 埃的正方体盒子中的 256 个无序 He 原子。 2.2.1 LJ 对势 LJ 对势的解析形式如下：u^{ij}表示原子 i 与原子 j 之间的相互作用能，r^{ij}表示这两个原子之间的距离，\\epsilon，\\sigma和r_{cut}则是 LJ 势需要的 3 个参数。LJ 势只考虑截断半径r_{cut}内的近邻原子 j 对中心原子 i 的能量贡献。 \\begin{array}{c} u^{i j}=4 \\varepsilon\\left[\\left(\\frac{\\sigma}{r_{i j}}\\right)^{12}-\\left(\\frac{\\sigma}{r_{i j}}\\right)^{6}\\right] \\\\ \\boldsymbol{F}_{i}=-\\nabla_{i} U=\\sum_{j} 4 \\varepsilon\\left[12\\left(\\frac{\\sigma}{r_{i j}}\\right)^{12}-6\\left(\\frac{\\sigma}{r_{i j}}\\right)^{6}\\right] \\frac{\\boldsymbol{r}_{i}-\\boldsymbol{r}_{j}}{r_{i j}^{2}} H\\left(r_{c u t}-r_{i j}\\right) \\end{array} \\\\ H(x)=\\left\\{\\begin{array}{l} 0\\ \\ \\ \\ (x0) \\end{array}\\right.\\\\ 2.2.2 STRU LJMD 是经典分子动力学，不需要提供 KPT，赝势和轨道文件，STRU 的前面几部分如下： ATOMIC_SPECIES He 4.0026 LATTICE_CONSTANT 1.889727 LATTICE_VECTORS 20 0 0 0 20 0 0 0 20 ATOMIC_POSITIONS Cartesian He #label 0 #magnetism 256 #number of atoms ATOMIC_SPECIES：不需要提供赝势信息 NUMERICAL_ORBITAL：不需要添加轨道信息 2.2.3 INPUT INPUT 文件中的参数也需要做少量修改： INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md pseudo_dir ../../PP_ORB #Parameters (esolver) esolver_type lj lj_rcut 8.5 lj_epsilon 0.01032 lj_sigma 3.405 cal_force 1 cal_stress 1 #Parameters (MD) md_nstep 5 md_type nve md_dt 1 md_tfirst 300 init_vel 1 esolver_type：指定为 lj 就可以做 Lennard-Jones 经典势函数。 lj_rcut：LJ 对势的参数，即截断半径r_{cut}。 lj_epsilon：LJ 对势的参数，即\\epsilon。 lj_sigma：LJ 对势的参数，即\\sigma。 init_vel：读取 STRU 中的原子速度信息，原子单位制。 2.3 深度势能（Deep Potential） ABACUS 软件包中提供了一个 DPMD 的算例，进入 3_DPMD 目录。该算例采用 DP 模型（DeePMD-kit 产生的深度势能模型）作为能量求解器来做基于机器学习的分子动力学，初始结构是 864 个无序铝原子。 2.3.1 DP 模型 DeePMD-kit 是一种基于机器学习的分子动力学模拟方法，该方法是通过使用第一性原理计算数据对深度神经网络模型进行训练，从而得到通用的多体势能模型（DP 模型）。 2.3.2 编译方式 ABACUS 采用 DP 模型做 MD 计算需要编译与 DeePMD-kit 的接口，cmake 以及 makefile 编译方式可以参考 ABACUS 线上文档。 2.3.3 INPUT 文件设置 DPMD 是经典分子动力学，不需要提供 KPT，赝势和轨道文件 INPUT 文件中的参数需要做少量修改： INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md esolver_type dp pot_file ../../PP_ORB/Al-SCAN.pb cal_force 1 cal_stress 1 md_nstep 3 md_type msst md_dt 1 md_tfirst 200 md_dumpfreq 1 md_restartfreq 1 msst_qmass 200 msst_vel 0.028 msst_vis 0.3 init_vel 1 esolver_type：设置为 dp pot_file：DP 模型文件路径 md_dumpfreq：MD 输出文件 MD_dump 中原子以及晶胞信息的输出频率 md_restartfreq：结构文件 STRU_MD_${istep} 的输出频率，MD 续算文件 Restart_md.dat 的更新频率 2.3.4 STRU 文件的设置 首先，我们可以通过如下命令确定 DP 势文件中是否存在关键字“type_map”： $ strings Al-SCAN.pb | grep type_map {\"model\": {\"type_map\": [\"Al\"], \"descriptor\": {\"type\": \"se_e2_a\", \"sel\": [150], \"rcut_smth\": 0.5, \"rcut\": 6.0, \"neuron\": [25, 50, 100], \"resnet_dt\": false, \"axis_neuron\": 16, \"seed\": 1, \"activation_function\": \"tanh\", \"type_one_side\": false, \"precision\": \"default\", \"trainable\": true, \"exclude_types\": [], \"set_davg_zero\": false}, \"fitting_net\": {\"neuron\": [240, 240, 240], \"resnet_dt\": true, \"seed\": 1, \"type\": \"ener\", \"numb_fparam\": 0, \"numb_aparam\": 0, \"activation_function\": \"tanh\", \"precision\": \"default\", \"trainable\": true, \"rcond\": 0.001, \"atom_ener\": []}, \"data_stat_nbatch\": 10, \"data_stat_protect\": 0.01}, \"learning_rate\": {\"type\": \"exp\", \"decay_steps\": 5000, \"start_lr\": 0.001, \"stop_lr\": 3.51e-08, \"scale_by_worker\": \"linear\"}, \"loss\": {\"type\": \"ener\", \"start_pref_e\": 0.02, \"limit_pref_e\": 1, \"start_pref_f\": 1000, \"limit_pref_f\": 1, \"start_pref_v\": 0, \"limit_pref_v\": 0, \"start_pref_ae\": 0.0, \"limit_pref_ae\": 0.0, \"start_pref_pf\": 0.0, \"limit_pref_pf\": 0.0, \"enable_atom_ener_coeff\": false}, \"training\": {\"training_data\": {\"systems\": [\"../deepmd_data/\"], \"batch_size\": \"auto\", \"set_prefix\": \"set\", \"auto_prob\": \"prob_sys_size\", \"sys_probs\": null}, \"validation_data\": {\"systems\": [\"../deepmd_validation\"], \"batch_size\": 1, \"numb_btch\": 3, \"set_prefix\": \"set\", \"auto_prob\": \"prob_sys_size\", \"sys_probs\": null}, \"numb_steps\": 1000000, \"seed\": 10, \"disp_file\": \"lcurve.out\", \"disp_freq\": 100, \"save_freq\": 1000, \"save_ckpt\": \"model.ckpt\", \"disp_training\": true, \"time_training\": true, \"profiling\": false, \"profiling_file\": \"timeline.json\", \"enable_profiler\": false, \"tensorboard\": false, \"tensorboard_log_dir\": \"log\", \"tensorboard_freq\": 1}} 如果存在关键字 type_map，那么 ABACUS 会自动匹配 STRU 和 DP 势文件中的原子种类顺序。 否则，STRU 中的原子种类以及顺序必须与 DP 势文件中的原子种类以及顺序一致。 例如，如果我们用 Al-Cu-Mg 三元合金的 DP 势文件来跑 Al-Mg 二元合金的 MD，那么 STRU 应该如下所示： ATOMIC_SPECIES Al 26.982 Cu 63.546 Mg 24.305 LATTICE_CONSTANT 1.889727000000 LATTICE_VECTORS 4.0 0.0 0.0 0.0 4.0 0.0 0.0 0.0 4.0 ATOMIC_POSITIONS Cartesian Al 0 2 0.0 0.0 0.0 0.5 0.5 0.0 Cu 0 0 Mg 0 2 0.5 0.0 0.5 0.0 0.5 0.5 注：在这个例子中，即使 Cu 原子的数量为 0，也必须在 STRU 中给出 Cu 原子相关信息。 3 MD 输出和续算功能 3.1 MD 输出文件 ABACUS 的 MD 模拟会产生 3 类输出文件：结构文件 STRU_MD_${istep}，续算文件 Restart_md.dat，信息文件 MD_dump。 3.1.1 结构文件 STRU_MD_${istep} 参数 md_restartfreq 控制 OUT.${suffix}/STRU/文件夹中结构文件STRU_MD_${istep}的输出频率，该文件格式与输入结构文件 STRU 相同，主要用于 MD 续算。这里 istep 代表离子步，从 0 开始计数。 3.1.2 续算文件 Restart_md.dat 参数 md_restartfreq 控制 OUT.${suffix}/Restart_md.dat 的更新频率，用于 MD 续算。 3.1.3 信息文件 MD_dump 参数 md_dumpfreq 控制 OUT.${suffix}/MD_dump 文件的追加输出频率，该文件输出每 md_dumpfreq 步的 MD 信息，包括 MD 步数，晶格常数，晶格矢量，晶格维里，原子编号，原子位置，原子受力，原子速度。其中，晶格维里，原子受力，原子速度可以通过输入参数 dump_virial，dump_force，dump_vel 控制是否输出。 MDSTEP: 0 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 123.045275146001 -3.807535058112 -13.541439282961 -3.807535058112 124.421300186299 24.047959743672 -13.541439282961 24.047959743672 125.016024430342 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 0.000000000000 0.000000000000 0.000000000000 -0.885362725233 0.500467424348 0.150239620206 -0.003506076235 0.000412570794 0.000094403053 1 Si 1.300822817264 1.376389287977 1.354798867769 0.885362725233 -0.500467424348 -0.150239620206 0.003506076235 -0.000412570794 -0.000094403053 MDSTEP: 1 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 123.051574098220 -2.465332696362 -10.608474638302 -2.465332696362 123.587154919736 16.307187552709 -10.608474638302 16.307187552709 123.960669810770 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 5.389827754452 2.701629481339 2.699621723525 -0.602062173578 0.391990779819 0.096323485153 -0.010548689866 0.004659227844 0.001267888485 1 Si 1.308600113700 1.373562332082 1.353979669688 0.602062173578 -0.391990779819 -0.096323485153 0.010548689866 -0.004659227844 -0.001267888485 MDSTEP: 2 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 122.953007762375 -0.240072876170 -4.211946086929 -0.240072876170 122.930693852071 3.378536464243 -4.211946086929 3.378536464243 122.992607262385 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 5.376757913710 2.708010452044 2.701308224779 -0.124946902346 0.155367961328 0.009378252255 -0.012739769308 0.006644009927 0.001613591879 1 Si 1.321669954442 1.367181361377 1.352293168434 0.124946902346 -0.155367961328 -0.009378252255 0.012739769308 -0.006644009927 -0.001613591879 MDSTEP: 3 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 122.881221914392 1.206247195689 2.345023988024 1.206247195689 123.110079832453 -8.436042066928 2.345023988024 -8.436042066928 123.123976300784 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 5.364727401370 2.714719749381 2.702800880457 0.310711926370 -0.086233730382 -0.043760493686 -0.009222308089 0.005510922784 0.001122226311 1 Si 1.333700466782 1.360472064040 1.350800512757 -0.310711926370 0.086233730382 0.043760493686 0.009222308089 -0.005510922784 -0.001122226311 3.2 MD 续算功能 如果 ABACUS 运行达到指定的 MD 步数，或者计算中断，可以通过 MD 续算功能继续之前的 MD 计算。 以上一个 INPUT 文件为例： INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md pseudo_dir ../../PP_ORB esolver_type dp pot_file ../../PP_ORB/Al-SCAN.pb cal_force 1 cal_stress 1 md_nstep 3 md_type msst md_dt 1 md_tfirst 200 md_dumpfreq 1 md_restartfreq 1 md_restart 1 msst_qmass 200 msst_vel 0.028 msst_vis 0.3 init_vel 1 md_restart：控制续算的开关，在 MD 续算时将这个参数设为 1，其他参数不变。当 md_restart 设为 1，ABACUS 会读取${read_file_dir}/Restart_md.dat文件，从中获取当前MD步数istep以及续算所需的其他参数如恒温器以及恒压器的信息，根据istep从OUT.${suffix}/STRU/ 文件夹中读取相应的结构文件 STRU_MD_${istep}，之后就可以进行 MD 续算了。 "},"abacus-sdft.html":{"url":"abacus-sdft.html","title":"ABACUS 随机波函数DFT方法使用教程","keywords":"","body":"ABACUS 随机波函数 DFT 方法使用教程 作者：陈涛，邮箱：chentao@stu.pku.edu.cn，最后更新时间：2023/04/29 1. 介绍 本教程旨在介绍 ABACUS 中随机波函数密度泛函理论（Stochastic Density Functional Theory，以下简称 SDFT）计算功能。目前 ABACUS 使用 SDFT 主要聚焦在高温高压物质的模拟，特别是温稠密物质（Warm Dense Matter，简称 WDM）。在进行温稠密物质计算时（温度高达数十到上千 eV， 1 eV=11604.5 K），传统的 Kohn-Sham 密度泛函理论（KSDFT）需要用到极大数量的占据态电子波函数导致计算困难，而 SDFT 使用随机波函数轨道，可以有效地避开对角化哈密顿矩阵这个问题，应用于高温计算。关于 ABACUS 中实现 SDFT 算法的细节可以参考 Qianrui Liu and Mohan Chen*, \"Plane-wave-based stochastic-deterministic density functional theory for extended systems,\" Phys. Rev. B, 106, 125132 (2022)。本教程中将会展示如何在 ABACUS 计算中使用 SDFT 功能，此外还会介绍混合随机波函数密度泛函理论方法使用（mixed stochastic-deterministic DFT，简称 MDFT），即在 SDFT 计算中，混入一部分的低能 Kohn-Sham 轨道，从而加速结果收敛。 2. 软件和算例准备 ABACUS 的软件包（3.2.0 版本）中提供了一个 SDFT 的算例，可以从 Gitee 上下载。可以在网页右侧点击克隆/下载-> 下载 ZIP 得到算例，或者在 linux 终端执行如下命令得到算例： git clone https://gitee.com/mcresearch/abacus-user-guide.git 下载后解压，之后进入/abacus-user-guide/examples/stochastic 文件夹。算例中有三个文件夹，pw_Si2、pw_md_Al 和 186_PW_SDOS_10D10S 3. 采用 SDFT 进行电子自洽迭代计算 pw_Si2文件夹：这是一个电子温度为 0.6 Ry（约 8.16 eV）的 2 个原子的金刚石结构硅（Si）的电子自洽迭代（Self Consistent Field，简称 SCF）算例，包含布里渊区 k 点的 KPT 文件和包含原子位置的 STRU 文件与传统的 KSDFT 计算并无区别，主要的不同在于输入文件 INPUT，注意目前 SDFT 仅支持 smearing_method 为 fd。INPUT 文件如下： INPUT_PARAMETERS #Parameters (General) calculation scf esolver_type sdft pseudo_dir ../../PP_ORB nbands 4 nbands_sto 64 nche_sto 100 method_sto 1 #Parameters (Accuracy) ecutwfc 50 scf_nmax 20 symmetry 1 #Parameters (Smearing) smearing_method fd smearing_sigma 0.6 以上参数在 ABACUS 的线上文档中均有详细说明，这里再进行简单概述： calculation设置为 scf，代表进行电子自洽迭代计算（self-consistent field）。 esolver_type是选择系统总能量求解方法的，默认为 ksdft（Kohn-Sham density functiona theory），这里需要设置为 sdft 才会使用 SDFT 或者 MDFT 进行计算。 nbands是使用的 Kohn-Sham 轨道的数目（也叫 determinstic orbitals，是通过严格对角化矩阵计算出来的）。如果 nbands 设置为 0，且 nbands_sto（随机轨道数目，这里设成 64）不为 0，则会进行 SDFT 计算；如果 nbands>0，且 nbands_sto>0，则会进行混合 KS 电子轨道和随机轨道（stochastic orbitals）的 MDFT 计算。注意：一般 nbands 设置为能量低于费米能级对应的能带数，计算效率会比较高。 nbands_sto是使用随机波函数（stochastic orbitals）轨道数目，原则上取得越大则随机误差越小，但计算效率也会相应降低。 注 1：如何判断随机波函数个数是否足够的一个经验法则是：测试能量误差，实际计算中，一般可以采用10 个左右不同的随机数种子（可以参考 seed_sto 参数设置随机数种子，下面有介绍）生成的相同数目的随机波函数轨道进行 SDFT 计算，增加随机波函数轨道数目直到控制能量误差小于万分之一即可。 注 2：当 nbands_sto 设为 0 时， 程序会自动转成 KSDFT 进行计算（ABACUS 3.2.2 版本以后）。 nche_sto是将电子体系的哈密顿量进行切比雪夫展开的阶数，这个数取得越大则用到的切比雪夫展开阶数越多，相应的计算精度也会越高但效率会降低。大致关系为与温度成反比，温度越高，阶数可以取得越小；ecut（正比关系）越大，阶数越大；推荐使用的 nche_sto 的大小是使得输出文件 running_scf.log 中的 Chebyshev Precision 小于 1e-8。 method_sto是进行 SDFT 计算使用的方法：1 代表消耗内存较少但稍慢的方法，2 代表更快但需要更大内存的方法，默认是 2。 注 1：在这个例子里我们提供的赝势是 Si.pz-vbc.UPF 文件，这个文件包含 4 个硅的价电子。事实上，当温度特别高的时候，一般的赝势可能会面临可移植性差的问题，例如高温会使得内壳层电离。这个时候，要选择合理的赝势进行计算，甚至可能需要自己造一个新的赝势，目前 ABACUS 3.2.0 支持的是模守恒的赝势。 注 2：ABACUS 的 SDFT 和 MDFT 支持多个 k 点采样，因此可以在 KPT 文件里设置不同的 k 点个数，在某些性质的计算里，要注意计算性质随着 k 点的收敛。 4. 采用 SDFT 进行分子动力学模拟 pw_md_Al 文件夹：这是一个电子温度为 7.35 Ry（约 100 eV）、包含 16 个铝（Al）原子的结构，我们对其进行分子动力学（Molecular Dynamics，简称 MD）的模拟。INPUT 文件如下： INPUT_PARAMETERS #Parameters (General) calculation md esolver_type sdft pseudo_dir ../../PP_ORB nbands 0 nbands_sto 64 nche_sto 20 method_sto 2 #Parameters (Accuracy) ecutwfc 50 scf_nmax 20 scf_thr 1e-6 symmetry 1 #Parameters (Smearing) smearing_method fd smearing_sigma 7.34986072 #Parameters (MD) md_tfirst 1160400 md_dt 0.2 md_nstep 10 注意要进行分子动力学模拟，calculation 参数需设置为 md。esolver_type 需设置为 sdft，才能进行 SDFT 的计算。这里 nbands 设置为 0，nbands_sto 设置为 64，代表仅仅使用随机轨道而没有 KS 轨道的 SDFT 计算。此外还有如下参数可能会用到： seed_sto：生成随机轨道的随机种子。默认是 0，代表随时间随机生成；若要控制使用相同的随机种子，可以设置一个大于 1 的整数。 bndpar：将所有并行的进程分成 bndpar 个组，计算所用随机轨道将平均分布在每个组中，可以提高并行效率，默认为 1。值得注意的是，这个参数并不是越大越好，并且不如 K 点并行（kpar参数）有效，实际计算中应该优先使用 K 点并行，然后测试不同大小的 bndpar，确定最佳的 bndpar。 平面波能量截断值 ecut 的测试：对于温稠密物质，一般使用 Gamma 点或 222 的 K 点即可，但是 ecut 的收敛性测试是必不可少的，由于随机误差的出现，SDFT 的 ecut 的测试与传统的 KSDFT 稍有区别，但是原理是类似的。在确定好 nbands_sto 后，就可以测试 ecut 了。与测试 nbands_sto 类似，在不同的 ecut，需要采用 10 个左右不同的随机种子生成的相同数目的随机波函数轨道进行 SDFT 计算，然后取平均能量。由于温稠密物质能量一般都比较高，因此只要控制相邻二个 ecut（相差为 10 Ry）对应的平均能量差小于一定标准即可（例如万分之一）。 5. 采用 SDFT 计算态密度 186_PW_SDOS_10D10S 文件夹：采用 SDFT 还可以计算给定体系的态密度（Density of States，简称 DOS）。例如，186_PW_SDOS_10D10S 是一个 1 个 Si 原子的算例。其中，INPUT 文件中我们将电子温度（通过设定 smearing_sigma）设为 0.6 Ry（约 8.16 eV），如下所示： INPUT_PARAMETERS #Parameters (1.General) suffix autotest calculation scf esolver_type sdft method_sto 2 nbands 10 nbands_sto 10 nche_sto 120 emax_sto 0 emin_sto 0 seed_sto 20000 pseudo_dir ../../PP_ORB symmetry 1 kpar 1 bndpar 2 #Parameters (2.Iteration) ecutwfc 20 scf_thr 1e-6 scf_nmax 20 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method fd smearing_sigma 0.6 #Parameters (5.Mixing) mixing_type broyden mixing_beta 0.4 out_dos 1 dos_emin_ev -20 dos_emax_ev 100 dos_edelta_ev 0.1 dos_sigma 4 dos_nche 240 npart_sto 2 以上参数在 ABACUS 的线上文档中均有说明，这里再进行简单概述： out_dos：需要设置为 1，才能输出能态密度。 dos_emin_ev：能态密度的能量最小范围，单位 eV。 dos_emax_ev：能态密度的能量最大范围，单位 eV。 dos_edelta_ev：控制输出DOS时的能量间隔，单位 eV。 dos_sigma：能态密度的高斯展宽的因子，单位 eV。 dos_nche：计算能态密度时切比雪夫展开阶数，默认为 100。 npart_sto：当使用 method_sto＝2 运行例如 DOS 的 SDFT 后处理时，将控制使用内存大小为正常的 1/npart_sto，防止内存不够导致无法计算，默认为 1。 注：态密度的输出文件是 OUT 文件夹下的 DOS1_smearing.dat。 6. 小结 总体来讲，随机波函数密度泛函理论方法（SDFT 或者 MDFT）的使用与 KSDFT 并无太大的区别，直接运行 ABACUS 程序即可，但是对一些关键参数的选取会影响精度和效率（例如 nbands, nbands_sto, nche_sto, method_sto, bnd_par）。对于极端高温计算（>10 eV），使用 SDFT 可以大大提高计算速度，是比普通的 KSDFT 更好的选择。如果大家使用有问题，欢迎写信联系（见上，或写信到 mohanchen@pku.edu.cn）。 "},"abacus-shengbte.html":{"url":"abacus-shengbte.html","title":"ABACUS+ShengBTE 计算晶格热导率","keywords":"","body":"ABACUS+ShengBTE 计算晶格热导率 作者：陈涛，邮箱：chentao@stu.pku.edu.cn，最后更新时间：2023/04/29 1. 介绍 本教程旨在介绍采用 ABACUS（基于 ABACUS 3.2.0 版本）做密度泛函理论计算，并且结合 ShengBTE 软件计算晶格的热导率的流程。其中，整个计算过程中还用到了：1）采用 Phonopy 程序来计算二阶力常数，2）采用 ASE 程序进行原子结构的转换，3）采用 ShengBTE 的 thirdorder 程序计算三阶力常数，4）最后使用 ShengBTE 来计算材料的晶格热导率。 上述提到了一些需要结合的外部软件，这里推荐大家阅读这些软件的相关文档和说明： ShengBTE：https://bitbucket.org/sousaw/shengbte/src/master/ phonopy：http://abacus.deepmodeling.com/en/latest/advanced/interface/phonopy.html ASE：http://abacus.deepmodeling.com/en/latest/advanced/interface/ase.html thirdorder: https://bitbucket.org/sousaw/thirdorder/src/master/ 2. 准备 ABACUS 的软件包中提供了一个 ABACUS+ShengBTE 计算晶格热导率的算例，可以从 Gitee 上下载。算例中包含采用数值原子轨道的 LCAO（Linear Combination of Atomic Orbitals）和采用平面波基矢量的 PW（Plane Wave，平面波）两个文件夹。每个文件夹下分别又包含了 2nd、3rd 和 shengbte 这三个文件夹，分别保存了使用 phonopy 计算二阶力常数（2nd）、thirdorder 计算三阶力常数（3rd）和 ShengBTE 计算晶格热导率（shengbte）的相关文件。 3. 流程 以 LCAO 文件夹为例，我们这里提供的测试案例是包含 2 个原子的金刚石结构 Si 结构，采用的模守恒赝势是 Si_ONCV_PBE-1.0.upf，以及原子轨道文件采用的是 Si_gga_7au_100Ry_2s2p1d.orb（GGA 泛函，7 au 截断半径，100 Ry 能量截断，以及包含 2s2p1d 的 DZP 轨道）。 3.1 计算二阶力常数 要计算二阶力常数，除了 ABACUS 之外，还需要结合 Phonopy 和 ASE。首先，进入 2nd 文件夹。 3.1.1 结构优化 做晶格热导率计算之前要先对模拟的材料体系的进行原子构型的优化。下面是采用 ABACUS 做结构优化（relax）后得到的原子构型文件 STRU。在这个例子里，为了简单起见，结构优化过程采用的是 2*2*2 的布里渊区 k 点采样，平面波的能量截断值 ecut（LCAO 里面也用到了平面波基矢量）为 100 Ry，注意实际计算中应该要采用更收敛的 k 点采样。 ATOMIC_SPECIES Si 28.0855 Si_ONCV_PBE-1.0.upf NUMERICAL_ORBITAL Si_gga_7au_100Ry_2s2p1d.orb LATTICE_CONSTANT 1.88972612546 LATTICE_VECTORS 0 2.81594778072 2.81594778072 #latvec1 2.81594778072 0 2.81594778072 #latvec2 2.81594778072 2.81594778072 0 #latvec3 ATOMIC_POSITIONS Direct # direct coordinate Si #label 0 #magnetism 2 #number of atoms 0.875 0.875 0.875 m 0 0 0 0.125 0.125 0.125 m 0 0 0 注意：第一行 Si 的质量 28.0855 在计算中不起作用。 3.1.2 计算二阶力常数 调用 Phonopy 软件产生需要计算的超胞及相应微扰的多个原子构型，命令如下： phonopy setting.conf --abacus -d 其中 setting.conf 文件的内容为： DIM = 2 2 2 ATOM_NAME = Si 这里我们采用的 Si 的例子只需要产生 1 个微扰构型 STRU-001 即可，对所有微扰构型（这里 Si 的例子只有 1 个）进行 SCF 计算（SCF 代表 Self-consistent field，这里代表进行密度泛函理论的电子迭代自洽计算）获得原子受力，算完之后用以下命令产生 FORCE_SET 文件： phonopy -f OUT.DIA-50/running_scf.log 小技巧：在 ABACUS 的输入文件 INPUT 中可以设置变量 stru_file，该变量对应的原子构型文件为 STRU-001 则 ABACUS 可以直接读取该结构文件。 下一步，设置 band.conf 文件计算得到声子谱以及二阶力常数： phonopy -p band.conf --abacus 这里出现的 band.conf 文件，其内容如下（具体参数含义可以查看 Phonopy 说明文档）： ATOM_NAME = Si DIM = 2 2 2 MESH = 8 8 8 PRIMITIVE_AXES = 1 0 0 0 1 0 0 0 1 BAND = 0.0 0.0 0.0 0.5 0.0 0.5 0.625 0.25 0.625, 0.375 0.375 0.75 00 0.0 0.0 0.5 0.5 0.5 BAND_POINTS = 101 BAND_CONNECTION = .TRUE. FORCE_CONSTANTS = WRITE FULL_FORCE_CONSTANTS = .TRUE. 这一步结束之后，Phonopy 软件会产生 band.yaml（用于绘制声子谱）和 FORCE_CONSTANTS 文件。其中，FORCE_CONSTANTS 文件包含的数据即为二阶力常数，注意这里务必设置 FULL_FORCE_CONSTANTS = .TRUE.，输出全部的二阶力常数，否则 ShengBTE 读取数据会报错。 此外，可以使用如下命令输出 gnuplot 格式的声子谱，用于绘制声子谱： phonopy-bandplot --gnuplot > pho.dat 3.1.3 后处理 注意 ShengBTE 软件要求 FORCE_CONSTANTS_2ND 文件里数据的单位为 eV/Å^2，但是 ABACUS 结合 phonopy 计算的 FORCE_CONSTANTS 单位为 eV/(Å*au)，其中 au 是原子单位制，1 au=0.52918 Å。可以使用 2nd 目录下提供的 au2si.py 脚本进行单位转换，生成 FORCE_CONSTANTS_2ND 文件，命令如下： python au2si.py 在 shengbte 文件夹中提供了 FORCE_CONSTANTS_2ND 文件供参考计算结果。 3.2 计算三阶力常数 要计算三阶力常数，需要结合 thirdorder 程序，计算后输出三阶力常数文件 FORCE_CONSTANTS_3RD。但是，thirdorder 目前只支持读取 VASP 和 QE 的输入输出文件。因此，这里我们是通过将 ABACUS 的结构文件和输出受力分别转换为 POSCAR 和 vasprun.xml 来使用 thirdorder，请先进入 3rd 文件夹，具体步骤将在以下叙述。 3.2.1 获得微扰构型 首先将 ABACUS 软件进行结构优化（relax）后的 STRU 文件转化为 POSCAR（目录下已给出转化过的 POSCAR，或者需要自己动手进行这个转换）。 之后，运行 thirdorder_vasp 程序，产生微扰过后的一系列原子构型文件 3RD.POSCAR.*，例如这个例子一共产生了 40 个构型： thirdorder_vasp.py sow 2 2 2 -2 运行 pos2stru.py，将上述 POSCAR 转化为 STRU 文件，注意该脚本里调用了 ASE 软件包的函数（需提前安装好 ASE）： python pos2stru.py 注意：这里不能调用 dpdata 软件进行转化。因为 dpdata 会强制将晶格改为下三角矩阵，相当于旋转了晶格，会导致原子间受力方向也相应旋转，从而发生错误。 3.2.2 计算微扰构型的原子受力 可以参考目录下 run_stru.sh 使用脚本批量产生 SCF-* 文件夹并提交计算，这里需要采用 ABACUS 对 40 个原子构型分别进行 SCF 计算，会有些耗时。建议每个 SCF 单独在 SCF-* 文件夹内运行，这里的 INPUT 中的scf_thr 需要至少小到1e-8才能得到收敛的结果。 计算完成后，运行 aba2vasp.py，将 ABACUS 计算的原子受力包装成 vasprun.xml 格式，放置在每个 SCF-* 文件夹中，命令如下： python aba2vasp.py vasprun.xml 格式示意： 1.865e-05 -0.04644196 -0.00153852 -1.77e-05 -0.00037715 -0.00149635 1.973e-05 0.002213 -0.00149461 -1.976e-05 0.00065303 -0.0014804 8.31e-06 -0.0003306 -0.00024288 -8.25e-06 -0.00038306 -0.00025385 1.071e-05 0.00060621 -0.00025797 -1.05e-05 -0.00014553 -0.00027532 0.00668053 0.00645634 -0.04642593 -0.00668085 0.00645595 -0.00040122 -0.00650454 0.00628877 -0.00025123 0.00650504 0.00628892 -0.00028948 -0.00039591 2.479e-05 0.00223371 0.00039608 2.426e-05 0.0006732 0.0003264 3.122e-05 0.00052874 -0.00032589 3.415e-05 -0.00023577 -2.908e-05 -0.00832477 0.00635709 3.737e-05 -0.00125057 -7.444e-05 -2.582e-05 0.00656076 0.00636285 2.566e-05 -0.00049974 -6.661e-05 -5.431e-05 0.00502637 0.00639077 4.553e-05 -0.00180978 0.0001325 -3.609e-05 -0.00676473 0.00638092 3.806e-05 5.503e-05 0.00012759 -0.00670704 0.00646596 0.01310437 0.00670119 3.673e-05 0.00602948 0.00036366 0.00627899 -0.00657272 -0.00036508 2.288e-05 0.00026009 0.00648649 0.0064463 -0.00036521 -0.00648098 1.594e-05 0.00671469 -0.00034493 0.00630074 0.00662932 0.00034331 4.157e-05 -0.0002028 最后执行如下命令： find SCF-* -name vasprun.xml|sort -n|thirdorder_vasp.py reap 2 2 2 -2 即可得到三阶力常数文件 FORCE_CONSTANTS_3RD。在 shengbte 文件夹中提供了 FORCE_CONSTANTS_3rd 文件供参考计算结果。 3.3 运行 ShengBTE 得到晶格热导率 进入 shengbte 文件夹，里面已经准备好 CONTROL（ShengBTE 的参数文件）、FORCE_CONSTANTS_2ND（二阶力常数文件）、FORCE_CONSTANTS_3RD（三阶力常数文件）这三个文件，使用如下命令运行 ShengBTE 即可得到晶格热导率，其中 Ref 文件夹中给出了计算结果供参考： mpirun -n 10 ShengBTE 4. 结尾 对于 ABACUS 中使用平面波（PW）来做 ShengBTE 的计算也是采用以上类似的流程，但要注意使用平面波时，计算三阶力常数的 INPUT 中scf_thr 需要至少小到1e-12。通过计算结果可以发现，PW 和 LCAO 基组计算出的 Si 的晶格热导率是接近的，300 K 下均在 100 W/(m K) 左右，而实验中 Si 在 300 K 的热导率在 150 W/(m K) 附近。这是因为作为教学例子，这里使用的是 2*2*2 的扩胞以及 2*2*2 的 K 点，导致计算结果偏小，实际科研中需要测试扩胞的大小以及 K 点的采样方案来达到收敛的结果。以上就是 ABACUS(3.2.0)+ShengBTE 计算晶格热导率的全部流程，如果有什么问题，欢迎通过邮件联系（chentao@stu.pku.edu.cn 或 mohanchen@pku.edu.cn）。 "},"abacus-dpgen.html":{"url":"abacus-dpgen.html","title":"ABACUS+DPGEN 使用教程","keywords":"","body":"ABACUS+DPGEN 使用教程 作者：刘建川，邮箱：liujianchuan2013@163.com，最后更新时间：2023/05/28 1. 介绍 本教程旨在介绍结合 ABACUS（中文名原子算筹，这里基于 ABACUS 3.2.0 版本）和 DPGEN 软件结合生成机器学习 DP 势，这里 ABACUS 扮演了提供第一性原理训练数据的作用。本教程以碳化硅（SiC）材料为案例，并且教大家使用 DPGEN autotest 功能，计算 SiC 的 Equation of State (EOS)和弹性常数等性质。先介绍主要软件和计算平台： DPGEN软件：是一个结合第一性原理软件来自动产生训练数据标签的软件，如果不熟悉 DPGEN 的读者，这里可以推荐大家先阅读 DPGEN 的相关原理文档和说明，熟悉这部分的读者可以跳过： https://docs.deepmodeling.com/projects/dpgen/en/latest/ https://bohrium-doc.dp.tech/docs/software/DP-GEN https://bohrium-doc.dp.tech/docs/software/DP-GEN_init https://bohrium-doc.dp.tech/docs/software/DP-GEN_autotest https://www.sciencedirect.com/science/article/pii/S001046552030045X?via%3Dihub 计算平台：由于本案例通过 Bohrium 平台教学，所以所用到的 machine.json 文件仅限于 Bohrium 平台使用，如需在其他平台上使用，可参考下面网址，修改 machine.json 文件： https://docs.deepmodeling.com/projects/dpgen/en/latest/run/example-of-machine.html 2. 准备 2.1 案例下载地址 本教程用到的所有输入文件，均可点击这里下载。 (https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/abacus-dpgen) 此外，在 Linux 下可以采用的下载命令是： git clone https://gitee.com/mcresearch/abacus-user-guide.git 之后进入 /abacus-user-guide/examples/md 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide/tree/master/examples/md 下载完之后，应该可以看到三个文件夹： init，run，以及 auto-test init 文件夹：包含用于 dpgen init_bulk 步骤所需的输入文件，用户可参考其设置自己的体系参数。 run 文件夹：包含用于 dpgen run 步骤所需的输入文件，用户可参考其设置自己的体系参数。 auto-test 文件夹：包含用于计算弹性常数等性质的输入文件，用户可参考其设置自己的体系参数。 2.2 安装相关软件 这里默认读者已经安装好了 ABACUS 软件，本算例中 ABACUS 计算采用的是数值原子轨道的 LCAO（Linear Combination of Atomic Orbitals）方法，因为一般来说 LCAO 会比平面波效率更高，此外读者也可以把密度泛函理论计算部分改成平面波基矢量（后续会讲到）。 开始之前，请务必安装/更新 dpgen 和 dpdata（用来转换数据）到最新版本： 1. 安装/更新 dpdata pip install --user git+``https://gitee.com/deepmodeling/dpdata.git@devel 2. 安装/更新 dpgen pip install --user git+``https://gitee.com/deepmodeling/dpgen.git@devel 3. 结合 DPGEN 生成 DP 数据的流程 DPGEN 使用流程如下，接下来我们将一一展开介绍： 3.1 准备赝势和数值原子轨道文件 本例子所需文件有： 模守恒赝势文件，格式为*.upf，也可以使用其他 ABACUS 支持的赝势格式，注意 ABACUS 目前不支持 PAW 方法或者超软赝势。 数值原子轨道文件，格式为*.orb，注意这里的数值原子轨道文件要和赝势文件匹配，也就是数值原子轨道是由指定赝势产生的，关于如何生成数值原子轨道，我们会提供中文教程。 注：在 ABACUS 官网上可以下载到赝势和数值原子轨道文件： http://abacus.ustc.edu.cn/pseudo/list.htm 本例采用的赝势和轨道是： C 的 PBE 模守恒 ONCV 模守恒赝势：C_ONCV_PBE-1.0.upf Si 的 PBE 模守恒 ONCV 模守恒赝势：Si_ONCV_PBE-1.0.upf C 的 PBE 模守恒 ONCV 赝势对应的数值原子轨道：C_gga_9au_100Ry_3s3p2d.orb Si 的 PBE 模守恒 ONCV 赝势对应的数值原子轨道：Si_gga_9au_100Ry_3s3p2d.orb 注：如果是使用平面波基矢量来做密度泛函理论计算，则不需要提供数值原子轨道文件，结合 DPGEN 使用的流程是一致的（仅需要删除调用轨道文件的输入参数即可）。如果采用其他 ABACUS 支持的赝势文件，可自行生成轨道文件（请参考本教程系列的其它相关中文教程）. 注：这里 C_gga_9au_100Ry_3s3p2d.orb 的意思是 C 元素、采用 GGA 泛函、轨道截断半径是 9 a.u.（轨道截断半径越大，则 ABACUS 所需求解 Kohn-Sham 方程的时间会越长，而且这个时间对于轨道半径极其敏感，推荐可以测试不同轨道半径，选取合适的、截断半径小的轨道可以加速计算），100 Ry 是推荐的平面波截断值（哪怕用了数值原子轨道，程序里还是会用平面波来做某些物理量的计算，比如模守恒赝势的局域赝势部分），3s3p2d 表示 3 个 s 径向轨道、3 个 p 轨道、2 个 d 轨道。 3.2 准备原子体系的结构文件 本步骤所需的描述原子结构的文件有： *.cif 可以从多个渠道下载所需体系的结构文件，本案例主要从 materials project 网站下载 cif 文件，使用的 SiC 对应多个原子构型，主要有 3C、2H、4H、6H 四个构型，采用哪些构型取决于用户所研究的体系和性质，一般可选取所关心的物质温度和压强区间内可能出现的结构。本案例主要采用3C 和 2H构型来演示。 3C-SiC：https://materialsproject.org/materials/mp-8062?formula=SiC 2H-SiC: https://materialsproject.org/materials/mp-7140?_skip=15&formula=SiC 4H-SiC: https://materialsproject.org/materials/mp-11714?formula=SiC 6H-SiC: https://materialsproject.org/materials/mp-7631?formula=SiC 得到了 cif 之后，可以使用下列方法把 cif 转换成 STRU 文件： 安装 ASE-ABACUS 接口： git clone https://gitlab.com/1041176461/ase-abacus.git cd ase-abacus python3 setup.py install 设置环境变量（可选） ABACUS 支持两种基组：平面波（PW）和数值原子轨道（LCAO）。赝势和轨道文件的存放路径可以通过环境变量设置，分别为：ABACUS_PP_PATH 和 ABACUS_ORBITAL_PATH,设置方法如下： PP=${HOME}/pseudopotentials ORB=${HOME}/orbitals export ABACUS_PP_PATH=${PP} export ABACUS_ORBITAL_PATH=${ORB} PW 计算只需要设置 ABACUS_PP_PATH 。 LCAO 需要两个都设置：ABACUS_PP_PATH and ABACUS_ORBITAL_PATH 。 CIF 转 STRU from ase.io import read, write from pathlib import Path cs_dir = './' cs_vasp = Path(cs_dir, 'SiC.cif') # 修改为自己的cif文件名 cs_atoms = read(cs_vasp, format='cif') cs_stru = Path(cs_dir, 'STRU') pp = {'Si':'Si_ONCV_PBE-1.0.upf','C':'C_ONCV_PBE-1.0.upf'} # 修改为所对应的赝势文件名 basis = {'Si':'Si_gga_9au_100Ry_3s3p2d.orb','C':'C_gga_9au_100Ry_3s3p2d.orb'} # 修改为所对应的轨道文件名 write(cs_stru, cs_atoms, format='abacus', pp=pp, basis=basis) 运行上述 python 脚本，把 cif 转成 ABACUS 所需的 STRU 文件。 3.3 产生初始训练数据 本步骤所需文件有： 原子结构文件：STRU 数值原子轨道文件：*.orb 赝势文件：*.upf 布里渊区 k 点采样：KPT 提交任务的文件：machine.json DPGEN 的输入参数文件：param.json 为每一个构型新建一个名为 init 的文件夹。进入该文件夹后，为每个构型都新建一个单独的文件夹，之后单独运行 dpgen init_bulk 命令，用于产生接下来的 dpgen run 步骤的初始数据集。本案例所提供的初始原子构型为 3C 和 2H 结构，并把赝势文件、轨道文件、STRU 文件放入对应的文件夹里。按照下面链接的案例准备适合自己机器的 machine.json 文件，并分别放入 3C 和 2H 文件夹。 https://docs.deepmodeling.com/projects/dpgen/en/latest/run/example-of-machine.html 本教程所用到的文件可以从 Gitee 下载，修改为符合自己的配置即可。 接下来准备 param.jsion 文件，本步骤最关键的设置也是 param.json 文件设置，案例如下： { \"init_fp_style\": \"ABACUS\", \"stages\": [1,2,3,4], \"cell_type\": \"diamond\", \"super_cell\": [1, 1, 1], \"elements\": [\"Si\",\"C\"], \"from_poscar\": true, \"from_poscar_path\": \"./STRU\", \"potcars\": [\"Si_ONCV_PBE-1.0.upf\",\"C_ONCV_PBE-1.0.upf\"], \"orb_files\": [\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C_gga_9au_100Ry_3s3p2d.orb\"], \"relax_incar\": \"./INPUT_rlx\", \"md_incar\" : \"./INPUT_md\", \"relax_kpt\": \"./KPT\", \"md_kpt\": \"./KPT\", \"md_nstep\": 10, \"scale\": [0.99,1.00,1.01], \"skip_relax\": false, \"pert_numb\": 10, \"pert_box\": 0.03, \"pert_atom\": 0.01, \"deepgen_templ\": \"../generator/template/\", \"coll_ndata\": 5000, \"_comment\": \"that's all\" } init_fp_style 关键字需设置为 ABACUS，如果 from_poscar 为 true，则会读取 from_poscar_path 指定的 STRU 文件，且 cell_type 关键字失效。super_cell 用于括胞，推荐直接使用括胞之后的 STRU 文件，则 super_cell 设置为[1, 1, 1]。括胞一般根据需求而定，使得三个方向的 cell 长度约为 6 埃以上（经验性的）。其中还用到了 *.``upf 和 *.``orb 文件，修改为自己所计算的体系即可。 init_bulk 的基本操作流程分为以下 4 个顺序步骤： 生成初始(平衡)结构：输出文件存储在 00.place_ele。 产生 MD 起始构象：放缩扰动 00.place_ele 中的结构，输出文件存储在 01.scale_pert。 执行 AIMD：取 01.scale_pert 起始构象调用 vasp 执行少步数 AIMD，输出文件存储在 02.md。 整理初始数据：调用 dpdata 提取 02.md 中 AIMD 各 snapshots 的数据作为初始数据，输出文件存储在 02.md。 param.json 中将使用 stages 关键词的取值 1~4 控制以上 4 步的执行，操作中，各步骤(2, 3, 4 在所需前一步输出文件存在的前提下)可独立执行。 其他具体参数含义可参考 dpgen 官网： https://docs.deepmodeling.com/projects/dpgen/en/latest/init/init-bulk-jdata.html 另外，还需准备两个 ABACUS 输入文件 INPUT_rlx 和 INPUT_md。 INPUT_rlx 主要用于优化所下载的结构，如下： INPUT_PARAMETERS #Parameters (1.General) suffix ABACUS calculation cell-relax #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type lcao #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.002 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.3 cal_stress 1 INPUT_md 主要用于产生一定数量的 AIMD 轨迹，用于 DPGEN 迭代的输出数据，如下： INPUT_PARAMETERS #Parameters (1.General) suffix ABACUS calculation md #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type lcao #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.002 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.3 cal_stress 1 #MD chg_extrap second-order md_type 2 md_tfirst 300 md_tlast 300 md_nstep 10 md_tfirst 10 md_tfreq 0.5 注：ABACUS 的 MD 关键字在此 3.2.0新版本有所更改，如果是使用的最新版本，请严格参考手册设置关键字，如md_type在新版本里改为了nvt、npt等形式，而不再用数字（如：2）等： 此外，还需准备一个存放布里渊区 k 点的文件，名为 KPT： K_POINTS 0 Gamma 4 4 4 0 0 0 也可在 INPUT 文件里直接指定 kspacing 参数（注意该参数可选 1 维或者 3 维，如果是表面系统可选 3 维因为真空方向不需要太多 k 点）。 用户可自行根据所研究体系，设置、更改上述参数。 所有以上输入文件准备完毕后，采用如下命令分别对 3C 和 2H 结构运行 dpgen： nohup dpgen init_bulk param.json machine.json 1>log 2>err& 上述命令采用后台提交 dpgen，等所有计算完成之后，dpgen 会自动收集训练 DP 势所需的数据，且转换为 DeePMD-kit 的数据格式，保存在 ./STRU.01x01x01/02.md/sys-0036-0036/deepmd 目录里。 3.4 进行数据采样的迭代 run主流程包含一系列迭代，各迭代会根据所选系综在给定的温度、压力或体积等条件下进行 DPMD 采样与筛选，实现同步学习，所有迭代希望能够有效覆盖训练可靠模型所需的势能面上样本空间。每个迭代依次：基于init 准备的初始训练数据与之前迭代积累的训练数据|训练多个新的模型->使用当前的模型进行DPMD采样，根据模型间预测偏差(model-deviation)|挑选候选 snapshot 构象->将本轮候选 snapshot 构象进行第一性原理标定并加入数据集|扩展数据集 。 以上每个迭代中包含的 3 个步骤分别被命名为 00.train，01.model_devi，02.fp，细节如下： 00.train: 使用 init 准备的初始训练数据与之前迭代积累的训练数据，调用 DeepMD-kit 训练多个 (默认 4 个) 模型。模型间的唯一区别来自于初始化神经网络时使用不同的随机数种子。 01.model_devi: 指代 model-deviation。 调用 LAMMPS 使用 00.train 的 1 个模型进行 MD 模拟。对于任一 MD 中 snapshot，模型间预测偏差越大意味着当前模型系综对该 snapshot 构象的精度越低，通过引入模型偏差作为误差判据并设定上下限, 挑选出有希望有效改进模型对 PES 整体预测精度的 snapshot 构象，作为准备加入训练数据集的候选构象。 02.fp: 调用 ABACUS 对 01.model_devi 选取的候选构象进行第一性原理定标(单点计算)，并调用 dpdata 收集整理所得数据加入到训练数据集中。 run 执行后，相关文件即存储在....../iter.*(迭代序号)/步骤文件夹内。以上每个迭代中的每个步骤在实现中被分解为 3 个阶段。以 00.train 为例，3 阶段分别对应: 0：make_train ，为训练任务准备脚本；1： run_train，依据机器配置上传文件并执行训练任务；2：post_train，收集整理分析训练任务的结果。01.model_devi 与 02.fp 的实现步骤与之类似，分别使用 3，4，5 及 6，7，8 来标记其阶段。 用输出文件record.dpgen来记录进程已经执行过及当前正在执行的阶段。如进程中断后需要续算，DP-GEN将根据此文件的记录来自动恢复run主进程。用户也可根据需求手动修改record.dpgen中的记录，来控制接下来将执行哪一阶段的任务：例如，删除最后一阶段(可能未执行完成即中断)的记录，并从前一个已完成阶段后恢复任务。可以通过查看record.dpgen文件监控当前任务的执行阶段。 本步骤所需文件有： STRU *.orb *.upf machine.json （可以直接用 dpgen init bulk 里的） param.json dpgen init bulk 产生的初始训练数据 主要步骤如下： 新建一个文件夹，命名为：run，并进入此目录里 在 run 文件夹里面新建 init_conf 和 init_data 文件夹，用于存放 dpgen init bulk 产生的构型和初始训练数据 为了区分不同构型和初始训练数据，在 init_conf 和 init_data 文件夹里新建名为 3C 和 2H 的两个文件夹 拷贝 dpgen init bulk 产生的构型和初始训练数据至 init_conf 和 init_data 文件夹里，如： cp -rf yourPath/init/3C/STRU.01x01x01/02.md/sys-0032-0032 yourPath/run/init_conf/3C cp -rf yourPath/init/2H/STRU.01x01x01/02.md/sys-0036-0036 yourPath/run/init_conf/2H cp -rf yourPath/init/3C/STRU.01x01x01/02.md/sys-0032-0032/deepmd/* yourPath/run/init_data/3C cp -rf yourPath/init/2H/STRU.01x01x01/02.md/sys-0036-0036/deepmd/* yourPath/run/init_data/2H 拷贝 machine.json、*.orb 和 *.upf 文件到 run 文件夹 新建一个 param.json 文件，如下案例： { \"type_map\": [\"Si\",\"C\"], \"mass_map\": [28.085,12.011], \"init_data_prefix\": \"./init_data\", \"init_data_sys\": [ \"3C\", \"2H\" ], \"sys_format\":\"abacus/stru\", \"sys_configs_prefix\": \"./init_conf\", \"sys_configs\": [ [\"3C/sys-0032-0032/scale-1.000/00****/STRU\"], [\"2H/sys-0036-0036/scale-1.000/00****/STRU\"] ], \"_comment\": \" that's all \", \"numb_models\": 4, \"default_training_param\": { \"model\": { \"type_map\": [\"Si\",\"C\"], \"descriptor\": { \"type\": \"se_e2_a\", \"sel\": \"auto\", \"rcut_smth\": 0.5, \"rcut\": 6.0, \"neuron\": [25, 50, 100], \"resnet_dt\": true, \"axis_neuron\": 12, \"seed\": 1 }, \"fitting_net\": { \"neuron\": [240, 240, 240], \"resnet_dt\": false, \"seed\": 1 } }, \"learning_rate\": { \"type\": \"exp\", \"start_lr\": 0.001, \"stop_lr\": 3.5e-8, \"decay_steps\": 2000 }, \"loss\": { \"start_pref_e\": 0.02, \"limit_pref_e\": 2, \"start_pref_f\": 1000, \"limit_pref_f\": 1, \"start_pref_v\": 0.0, \"limit_pref_v\": 0.0 }, \"training\": { \"stop_batch\": 400000, \"disp_file\": \"lcurve.out\", \"disp_freq\": 100, \"numb_test\": 10, \"save_freq\": 1000, \"save_ckpt\": \"model.ckpt\", \"disp_training\": true, \"time_training\": true, \"profiling\": false, \"profiling_file\": \"timeline.json\", \"_comment\": \"that's all\" } }, \"model_devi_dt\": 0.002, \"model_devi_skip\": 1000, \"model_devi_f_trust_lo\": 0.05, \"model_devi_f_trust_hi\": 0.10, \"model_devi_clean_traj\": true, \"model_devi_merge_traj\": true, \"model_devi_jobs\": [ {\"sys_idx\": [0,1], \"temps\":[50, 250, 450, 650], \"press\": [0, 100, 1000, 5000, 10000, 20000, 50000], \"trj_freq\": 10, \"nsteps\": 3000, \"ensemble\": \"npt-tri\", \"_idx\": \"01\"}, {\"sys_idx\": [0,1], \"temps\":[50, 250, 450, 650], \"press\": [0, 100, 1000, 5000, 10000, 20000, 50000], \"trj_freq\": 10, \"nsteps\": 3000, \"ensemble\": \"npt-tri\", \"_idx\": \"02\"} ], \"fp_style\": \"abacus\", \"shuffle_poscar\": false, \"fp_task_max\": 100, \"fp_task_min\": 5, \"fp_accurate_threshold\": 0.999, \"fp_accurate_soft_threshold\": 0.998, \"fp_pp_path\": \"./\", \"fp_pp_files\": [\"Si_ONCV_PBE-1.0.upf\",\"C_ONCV_PBE-1.0.upf\"], \"fp_orb_files\": [\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C_gga_9au_100Ry_3s3p2d.orb\"], \"user_fp_params\":{ \"ntype\": 2, \"symmetry\": 0, \"basis_type\": \"lcao\", \"ecutwfc\": 100, \"scf_thr\": 1e-6, \"scf_nmax\": 100, \"smearing_method\": \"gauss\", \"smearing_sigma\": 0.002, \"mixing_type\": \"pulay\", \"mixing_beta\": 0.3, \"cal_force\": 1, \"cal_stress\": 1, \"kspacing\": 0.08 } } type_map: 用列表方式设置了体系元素，注意顺序要和 STRU 结构文件里一致 mass_map: 记录了对应的原子质量，和 type_map 对应 init_data_prefix：指定初始训练集的位置所在目录，如：./init_data init_data_sys：定位到初始训练集的具体目录，用列表调用多个，即：./init_data/2H sys_format：指定为 ABACUS 计算的结构，即：abacus/stru sys_configs_prefix：指定探索步所需调用的结构目录，如：./init_conf sys_configs：指定具体的某个构型的目录，用列表调用多个，即：./init_conf/3C/sys-0032-0032/scale-1.000/00****/STRU。其中 00为通配符，dpgen 会遍历 00所有文件夹的 STRU 文件 model_devi_f_trust_lo 和 model_devi_f_trust_hi：可由“init 数据” 中力绝对值的平均值，然后取该值的 20%-50%，设置成 trust level 的上下限。可通过以下 python 脚本计算：（注意指定初始数据位置） import dpdata import numpy as np do06=dpdata.Labeledsystem(\"./\"，\"deepmd/raw\") forces = np.absolute(d006[\"forces\"]) af = np.average(forces) f_trust_lo = af*0.2 f_trust_hi = af*0.5 print(f_trust_lo,f_trust_hi) 如果体系温度升高后力的幅度变大，trust level 也要增大设置 model_devi_jobs 里面每一行代表一轮，每轮设置参数为 LAMMPS 进行 MD 模拟的参数 fp_style 指定，使用 ABACUS 进行 SCF 计算 user_fp_params 里面记录 ABACUS 做 SCF 所需的参数 其他参数含义见：https://docs.deepmodeling.com/projects/dpgen/en/latest/run/index.html 准备好所有输入文件之后，运行命令： nohup dpgen run param.json machine.json 1>log 2>err& 为后台提交，等待迭代计算完成即可。 实时监测每轮的 accurate 数据，在 dpgen.log 文件里有记录 1）模型精度是判断每个迭代中的训练是否收敛的重要指标。 2）掌握训练策略有利于快速迭代和收敛。 3）经验性：一般体系在 5-8 轮迭代内会上升到 80% 以上，若没有提升，如下方法排查： a. 检查是否是探索步已经崩溃了，收集了许多不合理的结构 b. 检查train的loss是否是收敛 c. dp test查看fp数据是否偏差很大，或者有不合理的情况 d. 检查是否是温度设置过高而导致的结构变形严重 e. 及时调整trust level，体系温度升高后力的幅度变大，trust level也要增大设置 一些经验 探索步已经崩溃的解决方案 原因：DPMD 跑崩的情况一般发生在 训练温度 高于 熔点，而这个温区的结构是从“有序”到“无序态”的 ，其构型易变，采样空间增大，导致训练难度增加。DPMD 跑崩表明当前势函数对这类构型描述较差，大概率是因为前期数据集中这类构型采集的较少；特别是无序态结构的原子距离变小。 策略：在熔点附近的 参数设置需要平滑缓慢对待，增加“MD 轨迹保存频率”；缩短“MD 模拟步数”或降低“MD 步长”，增加迭代次数，其 DP 训练势函数稳定后再延长 MD 模拟步数。 ABACUS 收敛性测试 对每种体系一定要先做各个参数的收敛性测试，特别是：K 点、能量截断，也可测试 scf_thr 降低计算量。另外，对于赝势文件也一定要做性质测试，看是否能够正确描述目标体系的性质 每隔几轮做一次 dp test 初始数据得到后，第一轮生成了 dp 势之后，一定要检查 trian 步骤收敛情况和做 dp test。dp test 用如下命令： dp test -m frozen_model.pb -s ./collect_data -n 2000 -d out.out frozen_model.pb 为生成的 4 个模型中的某一个，2000 为 collect_data 里面单个结构的总数。out.out 会生成 out.e.out out.f.out out.f.out 三个偏差数据文件，用于作图判断模型优劣屏幕会输出每个构型力、能量等误差平均值，也可用*.out 文件做出 DP 和 DFT 偏差图，如： 经验性的，力的精度在 1e-2 量级，能量精度在 5e-3 量级，说明模型比较好。 4. 计算材料 EOS 和弹性常数的流程 本例子里提供了一个 auto-test 文件夹，进入之后可以结合 DPGEN 的 auto-test 命令计算材料 EOS、弹性常数的流程 auto-test 的详细流程，可以从如下网页教程查阅： https://bohrium-doc.dp.tech/docs/software/DP-GEN_autotest 这里贴上如何使用 ABACUS 来计算材料 EOS、弹性常数的相关输入文件 relaxation.json： { \"structures\": [\"conf\"], \"interaction\": { \"type\": \"abacus\", \"incar\": \"./INPUT\", \"potcar_prefix\":\"./\", \"potcars\": {\"Si\": \"Si_ONCV_PBE-1.0.upf\",\"C\": \"C_ONCV_PBE-1.0.upf\"}, \"orb_files\": {\"Si\":\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C\":\"C_gga_9au_100Ry_3s3p2d.orb\"} }, \"relaxation\": { \"cal_type\": \"relaxation\", \"cal_setting\":{ \"input_prop\": \"./INPUT\" } } } property.json： { \"structures\": [\"conf\"], \"interaction\": { \"type\": \"abacus\", \"incar\": \"./INPUT\", \"potcar_prefix\":\"./\", \"potcars\": {\"Si\": \"Si_ONCV_PBE-1.0.upf\",\"C\": \"C_ONCV_PBE-1.0.upf\"}, \"orb_files\": {\"Si\":\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C\":\"C_gga_9au_100Ry_3s3p2d.orb\"} }, \"properties\": [ { \"type\": \"eos\", \"vol_start\": 0.9, \"vol_end\": 1.1, \"vol_step\": 0.02 }, { \"type\": \"elastic\", \"norm_deform\": 1e-2, \"shear_deform\": 1e-2 } ] } INPUT： INPUT_PARAMETERS calculation cell-relax symmetry 0 basis_type lcao ecutwfc 100.0 scf_thr 1.0e-06 scf_nmax 100 smearing_method gauss smearing_sigma 0.002 mixing_type pulay mixing_beta 0.3 cal_force 1 cal_stress 1 kspacing 0.10 在当前目录建立一个 conf 文件夹，把 STRU 文件放进去，依次运行下面命令： dpgen autotest make relaxation.json nohup dpgen autotest run relaxation.json machine.json & dpgen autotest post relaxation.json dpgen autotest make property.json nohup dpgen autotest run property.json machine.json & dpgen autotest post property.json 计算完成之后，会在 conf/elastic_00/result.out 文件里记录弹性常数、模量等信息，conf/eos_00/result.out 里记录 EOS 等数据。 以上即为采用 ABACUS 3.2.0 和 DPGEN 软件结合的介绍，若有任何问题，欢迎给我们反馈。 "},"contribute.html":{"url":"contribute.html","title":"如何贡献ABACUS使用教程","keywords":"","body":"如何贡献ABACUS使用教程 1. 明确教程格式 第一行，写作者姓名，单位，联系方式（例如Github ID或者邮箱），如果不愿意透露作者信息，也可以不写 第一部分“介绍”：本文档教程要展示的例子、要教授的内容有哪些，相关知识可以给一些参考文献。 第二部分“准备”：介绍输入文件需要哪些，最好是能够提供输入文件的下载（例如网上github仓库），或者直接贴上输入文件 第三部分“流程”：最好通过图文结合的方式，一步步的介绍每一步的命令，能得到什么结果。 第四部分“结语”：对这个功能使用需要注意的地方，或者可以应用的场景都可以给与相关介绍 2. 投稿 写好教程，检查无误后，AISI内部直接把稿件发给陈默涵老师（邮箱mohanchen@pku.edu.cn），或者向DeepModeling社区（deepmodeling@deepmodeling.com）投稿，审核通过后会加入到“ABACUS使用教程汇总” "}}